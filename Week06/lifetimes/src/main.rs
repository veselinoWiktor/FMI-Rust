use std::collections::HashMap;

// –ò—Å–∫–∞–º–µ –¥–∞ –Ω–∞–ø–∏—à–µ–º —Å–ª–µ–¥–Ω–∞—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è
// –§—É–Ω–∫—Ü–∏—è—Ç–∞ map_get –≤—Ä—ä—â–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è
// –ö–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞ –∏—Å–∫–∞ –¥–∞ –∑–Ω–∞–µ –∫–æ–ª–∫–æ –¥—ä–ª–≥–æ –µ –≤–∞–ª–∏–¥–Ω–∞ —Ç–∞–∑–∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è
// –ù–æ –≤ —Å–∏–≥–Ω–∞—Ç—É—Ä–∞—Ç–∞ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è—Ç–∞ –Ω—è–º–∞ –¥–æ—Å—Ç–∞—Ç—ä—á–Ω–æ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
// fn map_get(map: &HashMap<String, String>, key: &str) -> &str {
//     todo!();
// }

// Lifetimes

// –≤—Ä—ä—â–∞ –¥–≤–∞ —Ä–µ–∑–µ–Ω–∞ –æ—Ç –ø–æ–¥–∞–¥–µ–Ω–∏—è –Ω–∏–∑
// —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –µ –æ–±–≤—ä—Ä–∑–∞–Ω —Å –ø–∞—Ä–∞–º–µ—Ç—ä—Ä–∞ "text"
fn split_at(text: &str, index: usize) -> (&str, &str) {
    todo!();
}

// –≤—Ä—ä—â–∞ —Å—Ç–æ–π–Ω–æ—Å—Ç –æ—Ç —Ä–µ—á–Ω–∏–∫–∞ –ø–æ –∑–∞–¥–∞–¥–µ–Ω –∫–ª—é—á.
// —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –µ –æ–±–≤—ä—Ä–∑–∞–Ω —Å –ø–∞—Ä–∞–º–µ—Ç—ä—Ä–∞ `map`
fn map_get<'a>(map: &'a HashMap<String, String>, key: &str) -> &'a str {
    &"str"
}

// –≤—Ä—ä—â–∞ –ø–æ-–¥—ä–ª–≥–∏—è –æ—Ç –¥–≤–∞—Ç–∞ –Ω–∏–∑–∞.
// —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –µ –æ–±–≤—ä—Ä–∑–∞–Ω –∏ —Å `s1` –∏ —Å `s2`
fn longer<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    s1
}

// 'a
// —Å–µ –Ω–∞—Ä–∏—á–∞ lifetime –ø–∞—Ä–∞–º–µ—Ç—ä—Ä –∏–ª–∏ lifetime –∞–Ω–æ—Ç–∞—Ü–∏—è
// —Å–ø–µ—Ü–∏–∞–ª–µ–Ω –≤–∏–¥ generic –ø–∞—Ä–∞–º–µ—Ç—ä—Ä
// –∏–∑–ø–æ–ª–∑–≤–∞ —Å–µ –¥–∞ —Å–µ –æ–∑–Ω–∞—á–∏ –∫–æ–ª–∫–æ –¥—ä–ª–≥–æ –∂–∏–≤–µ–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è
// &`a X, &`b mut Y
// –º–æ–∂–µ –¥–∞ –µ –≤—Å—è–∫–∞–∫—ä–≤ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä, –Ω–æ –ø—Ä–∞–∫—Ç–∏–∫–∞—Ç–∞ –µ –¥–∞ —Å–∞ –∫—Ä–∞—Ç–∫–∏ –∏–ª–∏ –µ–¥–Ω–æ–±—É–∫–≤–µ–Ω–∏
// &'my_lifetime X

fn foo<'a>(x: &'a str) {
    todo!();
    // –æ—Ç–¥–µ–ª–Ω–æ x: &'a str –Ω–µ –Ω–∏ –¥–∞–≤–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
    // –∏–∑–º–∏—Å–ª–∏–ª–∏ —Å–º–µ —Å–∏ –∏–º–µ a –∑–∞ –ø–µ—Ä–∏–æ–¥–∞ –∑–∞ –∫–æ–π—Ç–æ –∂–∏–≤–µ–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è—Ç–∞ x
}

fn foo2<'a>(x: &'a str) -> &'a str { x }
// –ó–∞–µ–¥–Ω–æ x: &'a str –∏ -> &'a str –∑–∞–¥–∞–≤–∞—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ
// —Ä–µ–∑—É–ª—Ç–∞—Ç—ä—Ç –∂–∏–≤–µ–µ –∫–æ–ª–∫–æ—Ç–æ x

fn trim<'a>(s: &'a str) -> &'a str { s }

// –ù–µ –µ –Ω—É–∂–Ω–æ –≤—Å–∏—á–∫–∏ lifetime-–∏ –¥–∞ —Å–∞ –µ–¥–Ω–∞–∫–≤–∏
// —Ä–µ–∑—É–ª—Ç–∞—Ç—ä—Ç –µ —Å–≤—ä—Ä–∑–∞–Ω —Å –æ—Ä–∏–≥–∏–Ω–∞–ª–Ω–∏—è –Ω–∏–∑ `s`,  –Ω–æ –Ω–µ –µ —Å–≤—ä—Ä–∑–∞–Ω —Å `pattern`
fn first_occurances<'a, 'b>(s: &'a str, pattern: &'b str) -> Option<&'a str> {
    s.matches(pattern).next()
}

// Lifetimes elision
// –°–ª–µ–¥–Ω–∏—Ç–µ –¥–µ—Ñ–∏–Ω–∏—Ü–∏–∏ —Å–∞ –µ–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–∏
fn trim2(s: &str) -> &str {
    todo!();
}

fn trim3<'a>(s: &'a str) -> &'a str { todo!() }

// –ö–û–ì–ê –¢–†–Ø–ë–í–ê –î–ê –ü–ò–®–ï–ú Lifetimes

// –í –±–ª–æ–∫ –∫–æ–¥:
//      –ù–ò–ö–û–ì–ê
//      –ö–æ–º–ø–∏–ª–∞—Ç–æ—Ä—ä—Ç –≤–∏–Ω–∞–≥–∏ –∏–º–∞ –≤—Å–∏—á–∫–∞—Ç–∞ –Ω—É–∂–Ω–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–∞ –æ–ø—Ä–µ–¥–µ–ª–∏ –ø—Ä–∞–≤–∏–ª–Ω–∏—è Lifetime
// –í –¥–µ—Ñ–∏–Ω–∏—Ü–∏—è –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è
//      –ü–æ–Ω—è–∫–æ–≥–∞
//      –¢—É–∫ —Å–µ –ø—Ä–∏–ª–∞–≥–∞ lifetime elision
// –°—Ç—Ä—É–∫—Ç—É—Ä–∞
//      –í–∏–Ω–∞–≥–∏

// –ö–∞–∫ —Ä–∞–±–æ—Ç–∏

// (1) –ó–∞ –≤—Å–µ–∫–∏ –ø—Ä–æ–ø—É—Å–Ω–∞—Ç lifetime –≤ –∞—Ä–≥—É–º–µ–Ω—Ç–∏—Ç–µ —Å–µ –¥–æ–±–∞–≤—è –Ω–æ–≤ lifetime –ø–∞—Ä–∞–º–µ—Ç—ä—Ä
fn print(s: &str) {}          // elided
fn print2<'a>(s: &'a str) {}  // expanded

fn foo3(x: (&u32, &u32), y: usize) {}               // elided
fn foo4<'a, 'b>(x: (&'a u32, &'b u32), y: usize) {} // expanded

// (2) –ê–∫–æ –∑–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∏—Ç–µ –∏–º–∞ —Å–∞–º–æ –µ–¥–∏–Ω lifetime –ø–∞—Ä–∞–º–µ—Ç—ä—Ä (–µ–∫—Å–ø–ª–∏—Ü–∏—Ç–µ–Ω –∏–ª–∏ –ø—Ä–æ–ø—É—Å–Ω–∞—Ç), —Ç–æ–∑–∏ lifetime —Å–µ –Ω–∞–ª–∞–≥–∞ –Ω–∞ –≤—Å–∏—á–∫–∏ –ø—Ä–æ–ø—É—Å–Ω–∞—Ç–∏
// lifetimes –≤ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞

fn substr(s: &str, until: usize) -> &str { s }                              //elided
fn substr1<'a>(s: &'a str, until: usize) -> &'a str { s }                   //expanded

fn split_at1(s: &str, pos: usize) -> (&str, &str) { (s, s) }                // elided
fn split_at2<'a>(s: &'a str, pos: usize) -> (&'a str, &'a str) { (s, s) }   // expanded

// (3) –ê–∫–æ –ø—ä—Ä–≤–∏—è—Ç –∞—Ä–≥—É–º–µ–Ω—Ç –µ &self –∏–ª–∏ &mut self, –Ω–µ–≥–æ–≤–∏—è lifetime —Å–µ –Ω–∞–ª–∞–≥–∞ –Ω–∞ –≤—Å–∏—á–∫–∏ –ø—Ä–æ–ø—É—Å–Ω–∞—Ç–∏ lifetimes –≤ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞
// fn get_mut(&mut self) -> &mut T;                                 elided
// fn get_mut<'a>(&'a mut self) -> &'a mut T {}                     expanded

// fn args(&mut self, args: &[T]) -> &mut Self {};                  elided
// fn args<'a, 'b>(&'a mut self, args: &'b [T]) -> &'a mut Self {}  expanded

// –í—ä–≤ –≤—Å–∏—á–∫–∏ –æ—Å—Ç–∞–Ω–∞–ª–∏ —Å–ª—É—á–∞–π –µ –≥—Ä–µ—à–∫–∞ –¥–∞ –Ω–µ –Ω–∞–ø–∏—à–µ–º lifetime annotation

// –û–±–æ–±—â–µ–Ω–∏–µ
// –í—Å–∏—á–∫–∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏–∏ –∏–º–∞—Ç lifetime –ø–∞—Ä–∞–º–µ—Ç—ä—Ä (&'a X)
// –ï–¥–Ω–∞–∫—ä–≤ lifetime –ø–∞—Ä–∞–º–µ—Ç—ä—Ä - –¥–≤–µ—Ç–µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏–∏ –∂–∏–≤–µ—è—Ç –µ–¥–Ω–∞–∫–≤–æ –¥—ä–ª–≥–æ
// Lifetime elision

// –°–¢–ê–¢–ò–ß–ï–ù –ñ–ò–í–û–¢
// let s: &'static str = "–ù–∏–∑ –ª–∏—Ç–µ—Ä–∞–ª";
// –°–ø–µ—Ü–∏–∞–ª–µ–Ω lifetime `static
// –†–µ—Ñ–µ—Ä–µ–Ω–∏—Ü–∏—è—Ç–∞ –µ –≤–∞–ª–∏–¥–Ω–∞ –∑–∞ —Ü–µ–ª–∏—è –∂–∏–≤–æ—Ç –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞
// –õ–∏—Ç–µ—Ä–∞–ª–∏, –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∏, —Å—Ç–∞—Ç–∏—á–Ω–∏ –ø—Ä–æ–º–µ–Ω–ª–∏–≤–∏ –∏ –¥—Ä.
// –ü–æ-–≥–æ–ª—è–º –æ—Ç –≤—Å–µ–∫–∏ –¥—Ä—É–≥ lifetime 'a

// –†–µ—Ñ–µ—Ä–µ–Ω—Ü–∏–∏ –∫—ä–º —Å—Ç—É—Ä–∫—Ç—É—Ä–∏
#[derive(Debug)]
struct Words<'a>{
    text: Option<&'a str>,
}

/*
–∫–∞–∫—ä–≤ –¥–∞ –µ —Ç–∏–ø–∞ –Ω–∞ –ø–æ–ª–µ—Ç–æ text?
–Ω–µ –∏—Å–∫–∞–º–µ String -- –∏–∑–ª–∏—à–Ω–æ –∫–æ–ø–∏—Ä–∞–Ω–µ
–∏—Å–∫–∞–º–µ –¥–∞ –µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è
 */

use core::option::Option;
use std::fmt;

impl<'a> Words<'a> {
    /*
    fn new(text: &str) -> Words {
        Words { text }
    }
    // –ö–∞–∫ —Å–µ –ø–æ–ø—ä–ª–≤–∞ lifetime –∞–Ω–æ—Ç–∞—Ü–∏–∏—Ç–µ –∑–∞ new

    fn new<'b>(text: &'b str) -> Words<'b> {
        Words { text }
    }
    a–ª–≥–æ—Ä–∏—Ç—ä–º—ä—Ç –Ω–µ –≤–∑–∏–º–∞ –ø–æ–¥ –≤–Ω–∏–º–∞–Ω–∏–µ lifetime-–∞ 'a
    –ø—Ä–æ–ø—É—Å–Ω–∞—Ç–∏ lifetime –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ —Å–µ –ø–æ–ø—ä–ª–≤–∞—Ç –ø–æ —Å—ä—â–∏—è –Ω–∞—á–∏–Ω –∫–∞—Ç–æ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏–∏—Ç–µ
     */

    fn new(text: &'a str) -> Self {
        Words { text: Some(text) }
    }

    fn next_word(&mut self) -> Option<&'a str> {
        let text = self.text?;

        match text.split_once(char::is_whitespace) {
            Some((word, rest)) => {
                self.text = Some(rest);
                Some(word)
            }
            None => {
                self.text = None;
                Some(text)
            }
        }
    }

    // Anonymous lifetimes
    // –ú–æ–∂–µ–º –¥–∞ –∏–∑–ø–æ–ª–∑–≤–∞–º–µ –∞–Ω–æ–Ω–∏–º–µ–Ω lifetime '_

    fn make_words_iter(text: &str) -> Words<'_> {
        Words::new(text)
    }

    fn print_next_word(words: &mut Words<'_>) {
        if let Some(word) = words.next_word() {
            println!("{}", word);
        }
    }

    // –∑–∞ —É–¥–æ–±—Å—Ç–≤–æ –Ω–∞ —á–µ—Ç—è—â–∏—è
    // –ø–æ–∫–∞–∑–≤–∞, —á–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ç–∞ Words —Å—ä–¥—ä—Ä–∂–∞ elided lifetime
}


// –ò–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏—è –Ω–∞ next_word –º–µ—Ç–æ–¥–∞
// –í—Å–∏—á–∫–æ —Ä–∞–±–æ—Ç–∏, –Ω–æ –¥–∞–ª–∏ –∏–º–∞–º–µ –ø—Ä–∞–≤–∏–ª–Ω–∏—Ç–µ lifetimes?
fn hello() -> &'static str {
    let mut words = Words::new("hello world");
    words.next_word().unwrap()
}


#[cfg(test)]
mod tests{
    use super::*;

    #[test]
    fn words_basic() {
        let mut words = Words::new("hello world");
        assert_eq!(words.next_word(), Some("hello"));
        assert_eq!(words.next_word(), Some("world"));
        assert_eq!(words.next_word(), None);
    }

    #[test]
    fn empty_string() {
        let mut words = Words::new("");
        assert_eq!(words.next_word(), Some(""));
        assert_eq!(words.next_word(), None);
    }

    #[test]
    fn trailing_whitespace() {
        let mut words = Words::new("hello world ");
        assert_eq!(words.next_word(), Some("hello"));
        assert_eq!(words.next_word(), Some("world"));
        assert_eq!(words.next_word(), Some(""));
        assert_eq!(words.next_word(), None);
    }
}

// LIFETIMES & GENERICS
use std::fmt::Display;

struct Pretty<T: Display>(T);

impl<T: Display> Display for Pretty<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "üå∏üåπüåª {} üåªüåπüå∏", self.0)
    }
}

fn prepare_pretty<T: Display>(something: T) -> Pretty<T> {
    Pretty(something)
}

fn main() {
    let mut map = HashMap::new();
    map.insert(String::from("key"), String::from("value"));

    let value = {
        let key = String::from("key");
        let value = map_get(&map, &key);
        value
    };

    println!("{:?}", value);

    // --------------------------------------
    // –§—É–Ω–∫—Ü–∏—è—Ç–∞ trim –≤—Ä—ä—â–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç –∫–æ–π—Ç–æ –∂–∏–≤–µ–µ –∫–æ–ª–∫–æ—Ç–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∞
    {
        let s = String::from("   –Ω–∏–∑   \n"); // --+
        let trimmed = trim(&s);                  // --|-+
        //   | |
    } // <-------------------------------------------------+-+

    // -----------------------------------------
    //–§—É–Ω–∫—Ü–∏—è—Ç–∞ longer –≤—Ä—ä—â–∞ —Ä–µ–∑—É–ª—Ç–∞—Ç –∫–æ–π—Ç–æ –∂–∏–≤–µ–µ –∫–æ–ª–∫–æ—Ç–æ –æ–±—â–∏—è –ø–µ—Ä–∏–æ–¥ –≤ –∫–æ–π—Ç–æ –∂–∏–≤–µ—è—Ç –¥–≤–∞—Ç–∞ —ù –∞—Ä–≥—É–º–µ–Ω—Ç–∞.
    {
        // –ê–∫–æ –¥–≤–∞—Ç–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –∂–∏–≤–µ—è—Ç —Ä–∞–∑–ª–∏—á–Ω–æ - —â–µ —Å–µ –≤–∑–µ–º–µ –ø–æ-–º–∞–ª–∫–∏—è –ø–µ—Ä–∏–æ–¥
        // –∏–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –æ—Ç –ø–æ-–≥–æ–ª—è–º –¥–æ –ø–æ-–º–∞–ª—ä–∫ lifetime
        let s1 = String::from("–¥—ä–ª–≥–∏—è—Ç –Ω–∏–∑ –µ –¥—ä–ª—ä–≥"); // --+
        {                                                      //   |
            let s2 = String::from("–∫—ä—Å –Ω–∏–∑"); // --+       |
            let result = longer(&s1, &s2);        // --|--+    |
                                                       //   |  |    |
            println!("{}", result);                    //   |  |    |
        } // <----------------------------------------------+--+    |
                                                       //           |
    } // <----------------------------------------------------------+

    {
        // –ê–∫–æ –¥–≤–∞—Ç–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ –∂–∏–≤–µ—è—Ç —Ä–∞–∑–ª–∏—á–Ω–æ - —â–µ —Å–µ –≤–∑–µ–º–µ –ø–æ-–º–∞–ª–∫–∏—è –ø–µ—Ä–∏–æ–¥
        // –∏–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –æ—Ç –ø–æ-–≥–æ–ª—è–º –¥–æ –ø–æ-–º–∞–ª—ä–∫ lifetime
        // let s1 = String::from("–¥—ä–ª–≥–∏—è—Ç –Ω–∏–∑ –µ –¥—ä–ª—ä–≥"); -----------+
        // let result = {                                           |
        //     let s2 = String::from("–∫—ä—Å –Ω–∏–∑"); // --------+       |
        //     longer(&s1, &s2) ----------------------------|--+    |
        //                                                  |  |    |
        // };// <-------------------------------------------+--+    |
        //                                                          |
        // println!("{}", result) ERROR                             |
    } // <----------------------------------------------------------+

    /*
    error[E0597]: `s2` does not live long enough
      --> src/bin/main_6924ede250fd1bb1a0f74dfd79d60b37d4ab5cb1.rs:8:21
           |
        6  |     let result = {                                //   |
           |         ------ borrow later stored here
        7  |         let s2 = String::from("–∫—ä—Å –Ω–∏–∑"); // --+       |
           |             -- binding `s2` declared here
        8  |         longer(&s1, &s2)                  // --|--+    |
           |                     ^^^ borrowed value does not live long enough
        9  |                                           //   |  |    |
        10 |     }; // <------------------------------------+--+    |
           |     - `s2` dropped here while still borrowed

    For more information about this error, try `rustc --explain E0597`.
    error: could not compile `rust` (bin "main_6924ede250fd1bb1a0f74dfd79d60b37d4ab5cb1") due to 1 previous error
     */

    // ----------------------------------------------------------------------------------------------------
    {
        let text = String::from("–æ–±–∏—á–∞–º –º–∞—á –∏ –±–æ–∑–∞");
        let result = {
            let pattern = String::from("–±–æ–∑–∞");
            first_occurances(&text, &pattern)
        };

        println!("{:?}", result);
    }

    // –í—Å—è–∫–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è –∏–º–∞ lifetime, –∫–æ–π—Ç–æ —Å–µ —Å–ª–µ–¥–∏ –æ—Ç –∫–æ–º–ø–∏–ª–∞—Ç–æ—Ä–∞
    // –ù–æ –Ω–µ –µ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ –≤–∏–Ω–∞–≥–∏ –¥–∞ –≥–æ –∞–Ω–æ—Ç–∏—Ä–∞–º–µ
    // –ö–æ–≥–∞—Ç–æ —Å–∏—Ç—É–∞—Ü–∏—è—Ç–∞ –Ω–µ –µ –¥–≤—É—Å–º–∏—Å–ª–µ–Ω–∞ –º–æ–¥–µ –¥–∞ —Å–µ –ø—Ä–æ–ø—É—Å–Ω–µ
    // –¢–æ–≤–∞ —Å–µ –Ω–∞—Ä–∏—á–∞ lifetime elision

    // ---------------------------------------------------------------------------------------------------------
    // –†–ï–§–ï–†–ï–ù–¶–ò–Ø –í –°–¢–†–£–ö–¢–£–†–ò
    // –ñ–∏–≤–æ—Ç—ä—Ç –Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ç–∞ –µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω –¥–æ —Ç–æ–≤–∞ –∫–æ–ª–∫–æ –∂–∏–≤–µ–µ –æ–±–µ–∫—Ç—ä—Ç, –æ—Ç –∫–æ–π—Ç–æ —Å–º–µ –≤–∑–µ–ª–∏ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è
    {
        let t1 = Words::new("a b c"); // Words<'static>

        {
            let s = String::from("–º–æ–π —Ç–∞–µ–Ω –Ω–∏–∑"); // ---+ - 'a
            Words::new(s.as_str());                        //    | - Words<'a>
        }; // <--------------------------------------------------+
    }
    // ----------------------------------------------------------------------------------------------------------
    println!("{}", hello());

    // ----------------------------------------------------------------------------------------------------------
    {
        // `String` –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ `Display`
        let s: String = String::from("‚öò‚öò‚öò");

        // Pretty<String>
        let pretty = prepare_pretty(s);

        println!("{}", pretty);
    }

    {
        // `&String` –∏–º–ø–ª–µ–º–µ–Ω—Ç–∏—Ä–∞ `Display`
        let s: String = String::from("‚öò‚öò‚öò");

        // Pretty<&'a String>
        let pretty = prepare_pretty(&s);

        println!("{}", pretty);

        // generic —Ç–∏–ø T –º–æ–∂–µ –¥–∞ –µ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è
        //      –¢–æ–≥–∞–≤–∞ —Ç–æ–π –∏–º–∞ lifetime, –º–∞–∫–∞—Ä —á–µ –≤–∏–¥–∏–º–æ –Ω—è–º–∞ lifetime –ø–∞—Ä–∞–º–µ—Ç—ä—Ä
        //      –ò –≤—Å–µ–∫–∏ —Ç–∏–ø –∫–æ–π—Ç–æ —Å—ä–¥—ä—Ä–∂–∞ T —Å—ä—â–æ –∏–º–∞ lifetime, –∑–∞—â–æ—Ç–æ —Å—ä–¥—ä—Ä–∂–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è
        // generic —Ç–∏–ø T –º–æ–∂–µ –∏ –¥–∞ –µ —Ç–∏–ø —Å—ä—Å —Å–æ–±—Å—Ç–≤–µ–Ω–æ—Å—Ç
        //      –¢–æ–≥–∞–≤–∞ —Å–µ –ø—Ä–∏–µ–º–∞, —á–µ –∏–º–∞ `static lifetime
        // –¢ = &'a u32       ‚áí  T: 'a
        // T = &'static u32  ‚áí  T: 'static
        // T = u32           ‚áí  T: 'static
    }
}

